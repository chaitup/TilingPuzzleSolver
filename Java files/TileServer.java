import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.net.Socket;
import java.net.ServerSocket;
import java.util.ArrayList;
import java.util.List;

/**
 * This class will be called from targetboardfill . 
 * This will create each thread for the client connection 
 * and send the index and orientation of the the index tile and targetboardfill object to the client threads
 * It receives the solution list objects from each client which contains solutions generated by the client.
 * Once all the client calling is done , it will have all the solutions. Now it will call the isomorphic function to remove isomorphisc solutions
 *
 */public class TileServer{


	  public static ServerSocket tileServer = null;
	  public static Socket client = null;
	  public static Thread[] threads = new Thread[16];
	  public static List<IsomorphicSolutionCheck> solutions = new ArrayList<IsomorphicSolutionCheck>();//Holds all the solutions sent by client nodes 
	  
	  public static void main(TargetBoardFill boardFilling) {

	   int presentIndex = 0;//Index of the tile to be sent
	   int currentOrientation = 0;//orientation of tile that is being sent
	   // The default port number.
	   int portNumber = 9090;
	   try {
		   tileServer = new ServerSocket(portNumber);//opening server socket
		   while (presentIndex < boardFilling.memberTiles.length) {//This loop is continued till all the orientations of all the tiles are passed to client threads
			        client = tileServer.accept();//accepting the client request
			        for (int i = 0; i < 16; i++) {
			          if (threads[i] == null || (threads[i]!=null && threads[i].getState()== Thread.State.TERMINATED)) {			        	  
			            (threads[i] = new clientThread(client, presentIndex, currentOrientation, boardFilling)).start();
			            if(currentOrientation < ((boardFilling.memberTiles[presentIndex]).count)-1){
			            	currentOrientation++;
			            }
			            else{//Incrementing tile index only all orientations of a particular tile is completed
			            	presentIndex++;
			            	currentOrientation = 0;
			            }
			            break;
			          }
			        }
			      }  	
			for(int j=0; j < threads.length ; j++){// wait till all the threads get executed
				try{
					if(threads[j]!=null)  
						threads[j].join();			
			    }catch(InterruptedException ie){
			    	ie.printStackTrace();
			    }			          
		     }
	     	//Closing the socket and then checking for isomorphic solutions
	     	if(client!=null)
	     		client.close();
	     	
	     	for(int j=0; j<solutions.size(); j++){
	     		if (!boardFilling.isomorphic(solutions.get(j))){ 
	     			boardFilling.solutions.add(solutions.get(j));
	     		}
	     	}	
			}catch (IOException e) {
					e.printStackTrace();
					System.out.println(e);
	        }
	  }
}
/**
 * This class object is created and run method is called as thread, each individual thread sends the tile index , its orientation to the client, 
 *	and receives the individual client solutionlist and add to the solution list which contains all the clients solutions
 * 
 */
class clientThread extends Thread {

	  public InputStream is = null;
	  public OutputStream os = null;
	  public Socket client = null;
	  int presentIndex;
	  int currentOrientation;
	  List<IsomorphicSolutionCheck> solution = new ArrayList<IsomorphicSolutionCheck>();
	  TargetBoardFill boardFilling = null;
      ObjectOutputStream oos = null;
      ObjectInputStream ois = null;

	  public clientThread(Socket client, int  presentIndex, int currentOrientation, TargetBoardFill boardFilling) {
	    this.client = client;
	    this.presentIndex = presentIndex;
	    this.currentOrientation = currentOrientation;	    
	    this.boardFilling = boardFilling;
	  }
 
	  public void run() {
	    try {
	    	
		      is = client.getInputStream();
		      os = client.getOutputStream();
	      
		     oos = new ObjectOutputStream(os);
		     //Sending the board filling object , index of the tile to be placed in the first position on the board and orientation of that tile
			oos.writeObject(boardFilling);
			oos = new ObjectOutputStream(os);
			oos.writeObject(Integer.valueOf(presentIndex));
			oos = new ObjectOutputStream(os);
			oos.writeObject(Integer.valueOf(currentOrientation));
			
		    while(true) {
				
		    	ois = new ObjectInputStream(is);
			    //get the solution list from the client and add it to the solution list of the server class, if the size of solution is greater than 0 
			    solution = (List<IsomorphicSolutionCheck>)(ois.readObject());
			    if(solution != null){ 
		    		if(solution.size()!= 0)
		    		{	
		    			if(TileServer.solutions.size()==0){
		    				boardFilling.timeForFirstSolution = System.currentTimeMillis() - boardFilling.startingTime;
		    			}
		    			for(int i = 0; i < solution.size() ; i++){
		    				TileServer.solutions.add(solution.get(i));
		    			}
		    		}
		    		break;
			    }
		    }
	      ois.close();
	      oos.close();
	      is.close();
	      os.close();
	      client.close();
	    } catch (Exception e) {
	    	e.printStackTrace();
	    }
	  }
	}
